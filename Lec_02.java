// Отказоустойчивые приложения — приложения, которые при
// возникновении некритичных ошибок могут продолжать свою работу

// Тип исключения:
// # ArithmeticException Арифметическая ошибка
// # ArrayIndexOutOfВoundsException Выход индекса за пределы массива
// # ClassCastException Неверное приведение типов
// # IllegalArgumentException Употребление недопустимого аргумента при вызове метода
// # IndexOutOfВoundsException Выход индекса некоторого типа за допустимые пределы
// # NullPointerException Обращение к несуществующему объекту
// # NumberFormatException Неверное преобразование символьной строки в числовой формат
// # IOException Ошибка при работе с потоками ввода/вывода
// # FileNotFoundException Файл не найден
// # ClassNotFoundException Класс не найден
// # UnsupportedOperationException Попытка выполнения нереализованного метода

// 1. Exception — это ошибка, которую можно «на лету» перехватит и
// исправить.
// 2. Error — это критическая (непоправимая) ошибка, которую невозможно
// обработать, и которая приведёт к завершению работы JVM.

// Все исключения делятся на две группы:
// 1. Checked: класс Exception и его подклассы — исключения, которые вы
// обязаны обработать в собственном коде. Если этого не сделать,
// возникнет ошибка на этапе компиляции.
// 2. Unchecked: класс RuntimeException и его подклассы — исключения,
// охватывающие такие ситуации, как деление на ноль или ошибочная
// индексация массивов. Их можно обрабатывать, если есть вероятность
// возникновения. А можно и не обрабатывать, поскольку
// предполагается, что при правильном поведении программы такие
// исключения вовсе не должны возникать. Действительно, если массив
// состоит из 8 элементов, код не должен обращаться к десятому. Или
// при любом целочисленном делении надо проверять делитель.

// Обработка исключений
// 1. Поместить код, бросающий исключение, в блок try-catch.
// 2. Пробросить исключение методу на уровень выше, то есть методу,
// который вызывает текущий метод. Для этого используется ключевое
// слово throws.
// 3. [плохой путь] Вообще не обрабатывать исключение. Но в таком случае
// ваш код либо не скомпилируется, либо будет работать крайне
// нестабильно.


// Оператор throws. Если метод способен вызвать checked-исключение,
// которое сам не обрабатывает или просто не может корректно обработать, он
// должен задать своё поведение таким образом, чтобы вызывающий его код
// мог обезопасить себя от такого исключения.
// С этой целью в объявление метода вводится оператор throws, где
// перечисляются типы исключений, которые может генерировать метод. В
// таком случае метод «пробрасывает» указанные исключения. Ниже
// приводится общая форма объявления метода, которая включает оператор
// throws.

// Оператор finally образует блок кода, который выполняется по завершении
// блока операторов try/catch, но перед следующим за ним кодом. Он
// выполняется независимо от того, было ли сгенерировано исключение или
// нет, было ли оно перехвачено блоком catch или нет. Это удобно для закрытия
// файловых дескрипторов либо для освобождения других ресурсов, которые
// были выделены в начале метода и должны быть освобождены перед
// возвратом из него. Блок finally необязателен, но каждому оператору try
// требуется хотя бы один оператор catch или finally.


import java.io.File;

public class Lec_02 {
  public static void main(String[] args) {
    // ArithmeticException  -  / by zero
    // int a = 0;
    // int b = 10;

    // int c=b/a;
    // System.out.println(c);

    // NullPointerException
    String str = null;
    //System.out.println(str.length());

    // ArrayIndexOutOfBoundsException
    int[] array = new int[10];
    // array[100] = 5;

    // NumberFormatException
    // int value = Integer.parseInt (“100a0") ;

    // ClassCastException
    // Animal animal = new Cat();
    // Dog dog = (Dog) animal;

    // ClassCastException
    // Object object = new String ("123");
    // File file = (File) object;
    // System.out.println(file);

    try {
      int a = 10;
      //a -=10;
      int b = 42/a;
      int[] c = {1,2,3};
      c[42] = 99;
    } catch (ArithmeticException e) {
      System. out.println("Деление на ноль: " + e.getClass().getSimpleName());
    } catch (ArrayIndexOutOfBoundsException e) {
      System.out.println("Ошибка индексации массива: " + e.getClass().getSimpleName());
    }
    System. out.println("После блока операторов try/catch");
  }
}

